#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Aug  2 15:44:50 2022

@author: freddielloyd
"""

import numpy as np
import skfuzzy as fuzz
import matplotlib.pyplot as plt


# Generate universe variables
x_opinion_gap = np.arange(0, 1, 0.01)
x_weight = np.arange(0, 1, 0.01)


# Generate fuzzy membership functions 

# Opinion Gap Membership
# =============================================================================
# op_vsm = fuzz.trimf(x_opinion_gap, [0, 0, 0.1]) # very small
# op_qsm = fuzz.trimf(x_opinion_gap, [0, 0.1, 0.2]) # quite small
# op_sm = fuzz.trimf(x_opinion_gap, [0.1, 0.2, 0.3]) # small
# op_l = fuzz.trimf(x_opinion_gap, [0.3, 0.4, 0.5]) # large
# op_ql = fuzz.trimf(x_opinion_gap, [0.4, 0.5, 0.6]) # quite large
# op_vl = fuzz.trimf(x_opinion_gap, [0.5, 1, 1]) # very large
# 
# # Agent interaction update weight membership
# w_vstr = fuzz.trimf(x_weight, [0.8, 1, 1]) # very strong
# w_qstr = fuzz.trimf(x_weight, [0.6, 0.8, 1]) # quite strong
# w_str = fuzz.trimf(x_weight, [0.4, 0.6, 0.8]) # strong
# w_w = fuzz.trimf(x_weight, [0.2, 0.4, 0.6]) # weak
# w_qw = fuzz.trimf(x_weight, [0, 0.2, 0.4]) # quite weak
# w_vw = fuzz.trimf(x_weight, [0, 0, 0.2]) # very weak
# =============================================================================





# Opinion Gap Membership - NEW: 0.276 is very large and correspond to zero weight
op_vsm = fuzz.trimf(x_opinion_gap, [0, 0, 0.07]) # very small
op_qsm = fuzz.trimf(x_opinion_gap, [0, 0.07, 0.14]) # quite small
op_sm = fuzz.trimf(x_opinion_gap, [0.07, 0.14, 0.21]) # small
op_l = fuzz.trimf(x_opinion_gap, [0.14, 0.21, 0.28]) # large
op_ql = fuzz.trimf(x_opinion_gap, [0.21, 0.28, 0.35]) # quite large
op_vl = fuzz.trimf(x_opinion_gap, [0.28, 1, 1]) # very large


w_vstr = fuzz.trimf(x_weight, [0.83, 1, 1]) # very strong
w_qstr = fuzz.trimf(x_weight, [0.67, 0.83, 0.83]) # quite strong
w_str = fuzz.trimf(x_weight, [0.55, 0.7, 0.7]) # strong
w_w = fuzz.trimf(x_weight, [0.33, 0.33, 0.58]) # weak
w_qw = fuzz.trimf(x_weight, [0, 0.03, 0.35]) # quite weak
w_vw = fuzz.trimf(x_weight, [0, 0, 0]) # very weak




# Visualize these universes and membership functions

fig, (ax0, ax1) = plt.subplots(nrows=2, figsize=(10, 6))
#plt.ylim(-0.1,1.1)
#plt.xlim(-0.1,1.1)

ax0.plot(x_opinion_gap, op_vsm, 'r', linewidth=1.5, label='Very Small')
ax0.plot(x_opinion_gap, op_qsm, 'g', linewidth=1.5, label='Quite Small')
ax0.plot(x_opinion_gap, op_sm, 'b', linewidth=1.5, label='Small')
ax0.plot(x_opinion_gap, op_l, 'c', linewidth=1.5, label='Large')
ax0.plot(x_opinion_gap, op_ql, 'm', linewidth=1.5, label='Quite Large')
ax0.plot(x_opinion_gap, op_vl, 'y', linewidth=1.5, label='Very Large')
ax0.set_title('Opinion Gap')
ax0.legend(loc = 'right')
ax0.set_xlim(left=0)
ax0.set_ylim(bottom=0)

ax1.plot(x_weight, w_vstr, 'r', linewidth=1.5, label='Very Strong')
ax1.plot(x_weight, w_qstr, 'g', linewidth=1.5, label='Quite Strong')
ax1.plot(x_weight, w_str, 'b', linewidth=1.5, label='Strong')
ax1.plot(x_weight, w_w, 'c', linewidth=1.5, label='Weak')
ax1.plot(x_weight, w_qw, 'm', linewidth=1.5, label='Quite Weak')
ax1.plot(x_weight, w_vw, 'y', linewidth=1.5, label='Very Weak')
ax1.set_title('Interaction Weight')
ax1.legend(loc = 'right')
ax1.set_xlim(left=0)
ax1.set_ylim(bottom=0)

plt.tight_layout()

# =============================================================================
# # Turn off top/right axes
# for ax in (ax0, ax1):
#     
#     ax.spines['top'].set_visible(False)
#     ax.spines['right'].set_visible(False)
#     ax.get_xaxis().tick_bottom()
#     ax.get_yaxis().tick_left()
# 
# plt.tight_layout()
# 
# =============================================================================


# Now, to make these triangles useful, we define the *fuzzy relationships between input and output variables. 

# We need the activation of our fuzzy membership functions at a value for opinion gap.
# fuzz.interp_membership retrieves the y value for where the given opinion gap x value meets any of the 
# triangular membership functions

opinion_gap = 0.1

op_level_vsm = fuzz.interp_membership(x_opinion_gap, op_vsm, opinion_gap)
op_level_qsm = fuzz.interp_membership(x_opinion_gap, op_qsm, opinion_gap)
op_level_sm = fuzz.interp_membership(x_opinion_gap, op_sm, opinion_gap)
op_level_l = fuzz.interp_membership(x_opinion_gap, op_l, opinion_gap)
op_level_ql = fuzz.interp_membership(x_opinion_gap, op_ql, opinion_gap)
op_level_vl = fuzz.interp_membership(x_opinion_gap, op_vl, opinion_gap)


# Now apply the rules - here just 'if then' statements for each rule
# use np.fmin to take the element wise minimum of the y value obtained above for the opinion gap membership functions
# and the membership functions for weight - this essentially clips the triangular weight membership functions so
# their y values do not exceed the obtained values from above which is necessary for correct defuzzification
w_activation_1 = np.fmin(op_level_vsm, w_vstr)   
w_activation_2 = np.fmin(op_level_qsm, w_qstr)   
w_activation_3 = np.fmin(op_level_sm, w_str) 
w_activation_4 = np.fmin(op_level_l, w_w)   
w_activation_5 = np.fmin(op_level_ql, w_qw)   
w_activation_6 = np.fmin(op_level_vl, w_vw)         



# array of zeros same length as input array
weight0 = np.zeros_like(x_weight)

# Visualize this
fig, ax0 = plt.subplots(figsize=(8, 5))
plt.xlim(-0.1,1.1)
plt.ylim(-0.1,1.1)


ax0.fill_between(x_weight, weight0, w_activation_1, facecolor='r', alpha=0.7)
ax0.plot(x_weight, w_vstr, 'r', linewidth=0.5, linestyle='--', )
ax0.fill_between(x_weight, weight0, w_activation_2, facecolor='g', alpha=0.7)
ax0.plot(x_weight, w_qstr, 'g', linewidth=0.5, linestyle='--')
ax0.fill_between(x_weight, weight0, w_activation_3, facecolor='b', alpha=0.7)
ax0.plot(x_weight, w_str, 'b', linewidth=0.5, linestyle='--')
ax0.fill_between(x_weight, weight0, w_activation_4, facecolor='c', alpha=0.7)
ax0.plot(x_weight, w_w, 'c', linewidth=0.5, linestyle='--', )
ax0.fill_between(x_weight, weight0, w_activation_5, facecolor='m', alpha=0.7)
ax0.plot(x_weight, w_qw, 'm', linewidth=0.5, linestyle='--')
ax0.fill_between(x_weight, weight0, w_activation_6, facecolor='y', alpha=0.7)
ax0.plot(x_weight, w_vw, 'y', linewidth=0.5, linestyle='--')
ax0.set_title('Output membership activity')

# Turn off top/right axes
for ax in (ax0,):
    ax.spines['top'].set_visible(False)
    #ax.spines['right'].set_visible(False)
    ax.get_xaxis().tick_bottom()
    ax.get_yaxis().tick_left()

plt.tight_layout()





# Aggregate all six output membership functions together by taking element wise maximums
aggregated = np.fmax(w_activation_1,
                     np.fmax(w_activation_2,
                             np.fmax(w_activation_3,
                                     np.fmax(w_activation_4,
                                             np.fmax(w_activation_5, w_activation_6)))))

            
for i in range(len(x_weight)):
    print(x_weight[i], aggregated[i])

# Calculate defuzzified result
crisp_weight = fuzz.defuzz(x_weight, aggregated, 'centroid')
weight_activation = fuzz.interp_membership(x_weight, aggregated, crisp_weight)  # for plot


# Visualize this
fig, ax0 = plt.subplots(figsize=(8, 4))

ax0.plot(x_weight, w_vstr, 'r', linewidth=0.5, linestyle='--', )
ax0.plot(x_weight, w_qstr, 'g', linewidth=0.5, linestyle='--')
ax0.plot(x_weight, w_str, 'b', linewidth=0.5, linestyle='--')
ax0.plot(x_weight, w_w, 'c', linewidth=0.5, linestyle='--', )
ax0.plot(x_weight, w_qw, 'm', linewidth=0.5, linestyle='--')
ax0.plot(x_weight, w_vw, 'y', linewidth=0.5, linestyle='--')
ax0.fill_between(x_weight, weight0, aggregated, facecolor='Red', alpha=0.7)
ax0.plot([crisp_weight, crisp_weight], [0, weight_activation], 'k', linewidth=1.5, alpha=0.9)
ax0.set_title('Aggregated membership and result')
ax0.set_xlim(left=0)
ax0.set_ylim(bottom=0)

# =============================================================================
# # Turn off top/right axes
# for ax in (ax0,):
#     ax.spines['top'].set_visible(False)
#     ax.spines['right'].set_visible(False)
#     ax.get_xaxis().tick_bottom()
#     ax.get_yaxis().tick_left()
# 
# =============================================================================
plt.tight_layout()







# =============================================================================
# # Generate universe variables
# x_exact_opinion = np.arange(0, 1.01, 0.01)
# x_fuzzy_opinion = np.arange(0, 1.01, 0.01)
# 
# 
# # TEST FUZZIFYING OPINION
# 
# # Input - Strength of opinion - 10 levels as in Tao et al 2017
# input_op_vsm = fuzz.trimf(x_exact_opinion, [0, 0, 0.1]) # very small
# input_op_rsm = fuzz.trimf(x_exact_opinion, [0.1, 0.15, 0.2]) # rather small
# input_op_sm = fuzz.trimf(x_exact_opinion, [0.2, 0.2, 0.3]) #  small
# input_op_qsm = fuzz.trimf(x_exact_opinion, [0.2, 0.3, 0.4]) # quite small
# input_op_ssm = fuzz.trimf(x_exact_opinion, [0.3, 0.4, 0.5]) # slightly small
# input_op_n = fuzz.trimf(x_exact_opinion, [0.4, 0.5, 0.6]) # neutral
# input_op_ss = fuzz.trimf(x_exact_opinion, [0.5, 0.6, 0.7]) # slightly strong
# input_op_qs = fuzz.trimf(x_exact_opinion, [0.6, 0.7, 0.8]) # quite strong
# input_op_s = fuzz.trimf(x_exact_opinion, [0.7, 0.8, 0.9]) # strong
# input_op_rs = fuzz.trimf(x_exact_opinion, [0.8, 0.9, 1]) # rather strong
# input_op_vs = fuzz.trimf(x_exact_opinion, [0.9, 1, 1]) # very strong
# 
# 
# 
# # Output - Strength of opinion - 10 levels as in Tao et al 2017
# output_op_vsm = fuzz.trimf(x_fuzzy_opinion, [0, 0, 0.1]) # very small
# output_op_rsm = fuzz.trimf(x_fuzzy_opinion, [0, 0.1, 0.2]) # rather small
# output_op_sm = fuzz.trimf(x_fuzzy_opinion, [0.1, 0.2, 0.3]) #  small
# output_op_qsm = fuzz.trimf(x_fuzzy_opinion, [0.2, 0.3, 0.4]) # quite small
# output_op_ssm = fuzz.trimf(x_fuzzy_opinion, [0.3, 0.4, 0.5]) # slightly small
# output_op_n = fuzz.trimf(x_fuzzy_opinion, [0.4, 0.5, 0.6]) # neutral
# output_op_ss = fuzz.trimf(x_fuzzy_opinion, [0.5, 0.6, 0.7]) # slightly strong
# output_op_qs = fuzz.trimf(x_fuzzy_opinion, [0.6, 0.7, 0.8]) # quite strong
# output_op_s = fuzz.trimf(x_fuzzy_opinion, [0.7, 0.8, 0.9]) # strong
# output_op_rs = fuzz.trimf(x_fuzzy_opinion, [0.8, 0.9, 1]) # rather strong
# output_op_vs = fuzz.trimf(x_fuzzy_opinion, [0.9, 1, 1]) # very strong
# 
# 
# 
# 
# 
# 
# 
# # Now, to make these triangles useful, we define the *fuzzy relationships between input and output variables. 
# 
# # We need the activation of our fuzzy membership functions at a value for opinion gap.
# # fuzz.interp_membership retrieves the y value for where the given opinion gap x value meets any of the 
# # triangular membership functions
# 
# exact_opinion_input = 0.13
# 
# op_level_vsm = fuzz.interp_membership(x_exact_opinion, input_op_vsm, exact_opinion_input)
# op_level_rsm = fuzz.interp_membership(x_exact_opinion, input_op_rsm, exact_opinion_input)
# op_level_sm = fuzz.interp_membership(x_exact_opinion, input_op_sm, exact_opinion_input)
# op_level_qsm = fuzz.interp_membership(x_exact_opinion, input_op_qsm, exact_opinion_input)
# op_level_ssm = fuzz.interp_membership(x_exact_opinion, input_op_ssm, exact_opinion_input)
# op_level_n = fuzz.interp_membership(x_exact_opinion, input_op_n, exact_opinion_input)
# op_level_ss = fuzz.interp_membership(x_exact_opinion, input_op_ss, exact_opinion_input)
# op_level_qs = fuzz.interp_membership(x_exact_opinion, input_op_qs, exact_opinion_input)
# op_level_s = fuzz.interp_membership(x_exact_opinion, input_op_s, exact_opinion_input)
# op_level_rs = fuzz.interp_membership(x_exact_opinion, input_op_rs, exact_opinion_input)
# op_level_vs = fuzz.interp_membership(x_exact_opinion, input_op_vs, exact_opinion_input)
# 
# 
# 
# # Now apply the rules - here just 'if then' statements for each rule
# # use np.fmin to take the element wise minimum of the y value obtained above for the opinion gap membership functions
# # and the membership functions for weight - this essentially clips the triangular weight membership functions so
# # their y values do not exceed the obtained values from above which is necessary for correct defuzzification
# w_activation_1 = np.fmin(op_level_vsm, output_op_vsm)   
# w_activation_2 = np.fmin(op_level_rsm, output_op_rsm)   
# w_activation_3 = np.fmin(op_level_sm, output_op_sm) 
# w_activation_4 = np.fmin(op_level_qsm, output_op_qsm)   
# w_activation_5 = np.fmin(op_level_ssm, output_op_ssm)   
# w_activation_6 = np.fmin(op_level_n, output_op_n)   
# w_activation_7 = np.fmin(op_level_ss, output_op_ss)   
# w_activation_8 = np.fmin(op_level_qs, output_op_qs) 
# w_activation_9 = np.fmin(op_level_s, output_op_s)   
# w_activation_10 = np.fmin(op_level_rs, output_op_rs)   
# w_activation_11 = np.fmin(op_level_vs, output_op_vs)        
# 
# 
# 
# #weight0 = np.zeros_like(x_fuzzy_opinion)
# 
# 
# 
# # Aggregate all six output membership functions together by taking element wise maximums
# aggregated = np.fmax(w_activation_1,
#                      np.fmax(w_activation_2,
#                              np.fmax(w_activation_3,
#                                      np.fmax(w_activation_4,
#                                              np.fmax(w_activation_5, 
#                                                      np.fmax(w_activation_5, 
#                                                              np.fmax(w_activation_6, 
#                                                                      np.fmax(w_activation_7, 
#                                                                              np.fmax(w_activation_8, 
#                                                                                      np.fmax(w_activation_9, 
#                                                                                              np.fmax(w_activation_10, w_activation_11)))))))))))
#  
# 
# 
# # Calculate defuzzified result
# crisp_fuzzy_op = fuzz.defuzz(x_fuzzy_opinion, aggregated, 'centroid')
# 
# print('fuzzy opinion: ', crisp_fuzzy_op)
# 
# 
# 
# =============================================================================


















# Generate universe variables
x_exact_opinion = np.arange(0, 1.01, 0.01)
x_fuzzy_opinion = np.arange(0, 1.01, 0.01)


# TEST FUZZIFYING OPINION

# Input - Strength of opinion - 10 levels as in Tao et al 2017
input_op_vsm = fuzz.trimf(x_exact_opinion, [0, 0.1, 0.2]) # very small
input_op_sm = fuzz.trimf(x_exact_opinion, [0.125, 0.25, 0.375]) # small
input_op_qsm = fuzz.trimf(x_exact_opinion, [0.25, 0.35, 0.45]) #  quite small
input_op_n = fuzz.trimf(x_exact_opinion, [0.4, 0.5, 0.6]) # neutral
input_op_qs = fuzz.trimf(x_exact_opinion, [0.55, 0.65, 0.75]) # quite strong
input_op_s = fuzz.trimf(x_exact_opinion, [0.625, 0.75, 0.875]) # strong
input_op_vs = fuzz.trimf(x_exact_opinion, [0.8, 0.9, 1]) # very strong



# Output - Strength of opinion - 10 levels as in Tao et al 2017
output_op_vsm = fuzz.trimf(x_exact_opinion, [0, 0.1, 0.2]) # very small
output_op_sm = fuzz.trimf(x_exact_opinion, [0.125, 0.25, 0.375]) # small
output_op_qsm = fuzz.trimf(x_exact_opinion, [0.25, 0.35, 0.45]) #  quite small
output_op_n = fuzz.trimf(x_exact_opinion, [0.4, 0.5, 0.6]) # neutral
output_op_qs = fuzz.trimf(x_exact_opinion, [0.55, 0.65, 0.75]) # quite strong
output_op_s = fuzz.trimf(x_exact_opinion, [0.625, 0.75, 0.875]) # strong
output_op_vs = fuzz.trimf(x_exact_opinion, [0.8, 0.9, 1]) # very strong








# Now, to make these triangles useful, we define the *fuzzy relationships between input and output variables. 

# We need the activation of our fuzzy membership functions at a value for opinion gap.
# fuzz.interp_membership retrieves the y value for where the given opinion gap x value meets any of the 
# triangular membership functions

exact_opinion_input = 0.41

op_level_vsm = fuzz.interp_membership(x_exact_opinion, input_op_vsm, exact_opinion_input)
op_level_sm = fuzz.interp_membership(x_exact_opinion, input_op_sm, exact_opinion_input)
op_level_qsm = fuzz.interp_membership(x_exact_opinion, input_op_qsm, exact_opinion_input)
op_level_n = fuzz.interp_membership(x_exact_opinion, input_op_n, exact_opinion_input)
op_level_qs = fuzz.interp_membership(x_exact_opinion, input_op_qs, exact_opinion_input)
op_level_s = fuzz.interp_membership(x_exact_opinion, input_op_s, exact_opinion_input)
op_level_vs = fuzz.interp_membership(x_exact_opinion, input_op_vs, exact_opinion_input)



# Now apply the rules - here just 'if then' statements for each rule
# use np.fmin to take the element wise minimum of the y value obtained above for the opinion gap membership functions
# and the membership functions for weight - this essentially clips the triangular weight membership functions so
# their y values do not exceed the obtained values from above which is necessary for correct defuzzification
w_activation_1 = np.fmin(op_level_vsm, output_op_vsm)    
w_activation_2 = np.fmin(op_level_sm, output_op_sm) 
w_activation_3 = np.fmin(op_level_qsm, output_op_qsm)   
w_activation_4 = np.fmin(op_level_n, output_op_n)    
w_activation_5 = np.fmin(op_level_qs, output_op_qs) 
w_activation_6 = np.fmin(op_level_s, output_op_s)   
w_activation_7 = np.fmin(op_level_vs, output_op_vs)        



#weight0 = np.zeros_like(x_fuzzy_opinion)



# Aggregate all six output membership functions together by taking element wise maximums
aggregated = np.fmax(w_activation_1,
                     np.fmax(w_activation_2,
                             np.fmax(w_activation_3,
                                     np.fmax(w_activation_4,
                                             np.fmax(w_activation_5, 
                                                     np.fmax(w_activation_5, 
                                                             np.fmax(w_activation_6, w_activation_7)))))))

# Calculate defuzzified result
crisp_fuzzy_op = fuzz.defuzz(x_fuzzy_opinion, aggregated, 'centroid')

print('fuzzy opinion: ', crisp_fuzzy_op)